var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Brunner Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020.\nThe logo was created using ChatGPT from OpenAI.","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In the following, we explain how to load data and how to compute model weights.","category":"page"},{"location":"getting-started/#How-to-load-data","page":"Getting started","title":"How to load data","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The data to be loaded is specified in yaml config files. There are two  possibilities how to organize these config files: either we use one or more  ESMValTool recipes that we had used to preprocess the data or we write a new  yaml file, independently of the ESMValTool recipes.","category":"page"},{"location":"getting-started/#Configuration-with-ESMValTool-recipes","page":"Getting started","title":"Configuration with ESMValTool recipes","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We use the completely spelled out versions of the recipes that ESMValTool returns (RECIPENAME_filled.yml, stored in run-directory).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"import ModelWeights as mw\n\n# set path_data to directory where your preprocessed data is stored\npath_data = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/LGM\";\n# set path_recipes: directory where the ESMValTool recipes are stored \npath_recipes = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/configs-ModelWeights/esmvaltool-recipes/lgm-cmip5-cmip6\";\n\nlgm_data = mw.loadDataFromESMValToolRecipes(\n    path_data, path_recipes;\n    dir_per_var = true, # default: true\n    is_model_data = true, # default: true\n    subset = nothing, # default: nothing\n    preview = false # default: false; if true meta data for data to be loaded is returned\n);","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The loaded data is a Dictionary mapping from an identifier of the form 'variable_diagnostic_alias' (e.g., tas_CLIM_lgm) to a YAXArray. Additional metadata that was added by us is part of the YAXArrays .properties dictionary. All such fields start with an underscore, e.g. '_id', '_paths', '_statistic'.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Not all information in the ESMValTool recipes is required to specify the data to be loaded here. For a minimal example of the required structure, see this example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- TODO: explain dir_per_var argument -->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"How the loaded data can be constrained by the subset argument of the function loadDataFromESMValToolRecipes is described further below. ","category":"page"},{"location":"getting-started/#Configuration-with-seperate-yaml-file","page":"Getting started","title":"Configuration with seperate yaml file","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For an example of a single yaml configuration file see this example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Keys expected in the config-yaml file:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"path_data: base path to where the preprocessed data is stored. This path will be concatenated with the directories specified for each dataset. It can ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"be omitted if inside datasets (see below), base_dir refers to the entire absolute path.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"datasets: list of each dataset to be loaded. Each dataset is specified by a dictionary with the following keys:\nbase_dir::String: relative path to the data with respect to the path given in path_data. If path_data is not specified in the config file, path_data for this dataset is assumed to refer to an absolute path instead.\nexp::String: e.g., \"historical\"\nvariables::Vector{String}: e.g., [\"tos\", \"tas\"]\nstatistics::Vector{String}: may be empty for fixed variables for which no statistics are computed. In that case, statistics is set to [\"none\"] and a warning is thrown unless for known fixed variables (for now just [orog]).\nThe following keys are optional:\nsubdirs: vector of strings; only subdirectories that contain any of the given strings in their name will be considered.\ntimeranges:\naliases:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"datasets: [\n{\n    base_dir: \"LGM\", \n    exp: \"lgm\", \n    variables: [\"tas\", \"tos\"], \n    statistics: [\"CLIM\"], \n    subdirs: [\"20241114\"]\n},\n{\n    base_dir: \"historical\", # required String\n    exp: \"historical\", # required String\n    variables: [\"tas\", \"tos\"], # required Vector\n    statistics: [\"CLIM\"], # required Vector\n    timeranges: [\"full\"], # optional Vector\n    subdirs: [\"20241121\", \"20241118\"] # optional Vector\n}\n]","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"timerange_to_alias: mapping from timerange to alias.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"timerange_to_alias:\n\"1850-1900\": \"historical0\"\n\"1951-1980\": \"historical1\"","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For each given dataset the respective data is loaded from the base_dir at path_data. The keys base_dir, exp, variables and statistics are required to  specify the data to be loaded.  timeranges and subdirs are optional and work in the same way as when given as field of the optional argument subset described below.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As we'll explain next, you can also provide further constraints when loading the data using the function loadDataFromYAML. Note that in this case, the values from the provided function argument (subset::Constraint) to filter the data take precedence over what had been specified in the yaml file. ","category":"page"},{"location":"getting-started/#Optional-parameters-for-filtering-data","page":"Getting started","title":"Optional parameters for filtering data","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For both functions, loadDataFromESMValToolRecipes and loadDataFromYAML, there is a set of optional parameters in order to constrain the loaded data:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"preview: If set to false (default), the data will not be loaded and only the metadata with the information that we added that specifies which data will be loaded is returned.\ndir_per_var: If set to true (default), only subdirectories of the base_path that contain _VARIABLE in their name will be searched. \nis_model_data: is set to true (default) when loading CMIP data, to false when loading observationa/reanalysis data (e.g. ERA5).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- `subset_shared`: Can be either `nothing` (default), `ModelWeights.MODEL` or `ModelWeights.MEMBER`. If set to `MODEL`, only data from the same models will be loaded. If, for instance, data from lgm and historical experiments shall be loaded, this configuration will ensure that for both, only the same models are loaded, i.e. those for which both experiments were done. While this considers models, not specific simulations, setting subset\\_shared to `MEMBER` would only load models that share the exact same simulations (i.e. the same member\\_id abbreviation, e.g. `r1i1p1f1`). -->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"subset is an optional parameter of type Constraint or Nothing. A Constraint further constrains the data to be loaded and has the following fields:\nvariables: The short name of the climate variable, e.g. [\"tas\", \"tos\"].\nstatistics: The statistic/diagnostic that was used when preprocessing the data. The names are generally arbitrary, but need to be identical to those you used in the preprocessing; for instance, we refer to the climatological average as \"CLIM\", s.t. an example value for this argument is [\"CLIM\"].\naliases: Like for statistics, the names are arbitrary but must be identical to what you used when preprocessing the data; e.g. [\"historical\", \"historical1\"].\nAn alias should refer to a certain timerange of a certain experiment, e.g. we call the time period from 1951-1980 'historical1'. To load only this data, it thus does not matter whether you set timerange=[\"1951-1980\"] or alias=[\"historical1\"].\ntimeranges: Timeranges to be loaded; especially for historical data, you may preprocess data for different timeranges,  e.g. [\"full\", \"1980-2014\"]. \nprojects:  e.g. [\"CMIP5\", \"CMIP6\"]. All filenames of the data to be loaded must contain at least one of the given strings. If not specified and is_model_data=true, it is set to [\"CMIP\"]. If not specified and is_model_data=false, it is set to [\"ERA5\"], the default observational dataset used.\nmodels: List of models or individual model members, e.g. [\"AWI-CM-1-1-MR\"]. All filenames must contain at least one of the given strings + \"_\". The underscore is important since some models have names that are substrings of other models, e.g. \"CNRM-CM5\" and \"CNRM-CM5-C2\". \nsubdirs: If given, data will be loaded only from subdirectories of the given basedir that contain any of the provided values in their name. This is recommended when there are many subdirectories for a specific variable  within base\\dir and you only want data from a specific one (e.g. of a certain date, given that the date is included in the name of the directory).","category":"page"},{"location":"getting-started/#How-to-compute-weights","page":"Getting started","title":"How to compute weights","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For a full example, see scripts/run-climwip-simplified.yml.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- TODO: update the following -->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Calling mw.computeWeights(dists_indep, dists_perform, config) will compute weights based on the distances for the independence weights and the distances for the performance weights. The config parameter is of type ConfigWeights defined in src/data-utils.jl. It holds information about the contribution of each combination of statistic/diagnostic and climate variable, once for computing independence weights and once for computing performance weights. Further parameters concerning the weighting are specified in the ConfigWeights struct, such as the hyperparameters,  sigma_performance and sigma_independence. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- TODO: update following-->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The output of the function computeWeights is an object of type Weights (see src/data-utils.jl) which holds the weights for all combinations of statistics/diagnostics and climate variables, for performance as well as independence weights. Further, it contains the overall weights (one for each model, summing up to 1) as well as the performance and independence weights for each variable (summed across statistics/diagnostics).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- `weights_variables:`: For each of 'performance' and 'independence' one value per climate variable considered. These values represent the weight of how much each climate variable influences the generalized distance of a model, which is computed by taking a weighted average across the distances with respect to different variables. Should sum up to 1.  -->","category":"page"},{"location":"examples/climwip/#Climwip-example-from-Brunner-et-al.-(2020)","page":"Climwip example from Brunner et al. (2020)","title":"Climwip example from Brunner et al. (2020)","text":"","category":"section"},{"location":"weights/#Computing-weights","page":"Computing weights","title":"Computing weights","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The weighting method that we use is from Brunner et al. (2020), see References.","category":"page"},{"location":"weights/#Area-weighted-RMSE","page":"Computing weights","title":"Area-weighted RMSE","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"d_i^k = sqrtsum_l w_l (X_l^a (ik) - X_l^a obs)^2","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The variable d_i^k is the area-weighted root mean squared error between the predictions of a model, namely the k-th member of model i, and the observational data (or for independence weights between pairs of models):","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"Variable l iterates over (lon, lat)-positions and w_l are the area weights, which account for the different grid cell areas depending on the latitudes. d_i^k is computed for all individual model members, for each diagnostic and variable (denoted as a, which may, for instance, refer to the climatological average, CLIM, of near-surface air temperature, tas).","category":"page"},{"location":"weights/#Generalized-distances","page":"Computing weights","title":"Generalized distances","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The weights are computed for each model (i.e. not on the level of model members). They are based on the generalized distances.  To compute the generalized distances and subsequently the actual weights per model (w_i), the different members of each model are first summarized to yield one distance value per model. This is defined as the average distance, d^prime_i over all distances of K_i members of model i (for a specific combination of diagnostic and variable a): ","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"d_i ^prime a = fracsum_k^K_i d_i^kK_i","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The generalized distances are then defined as follows:","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"D_i = sum_a w_a cdot fracd_i^prime atextrmMEDIAN(d^a)","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"Here, the sum iterates over the combination of diagnostics and variables (a) and w_a refers to the weights for each combination of diagnostic and variable. So, D_i is the weighted average over all model distances which are further normalized by the median computed across all model members, seperately for each combination of diagnostic and variable. So, d^a in the denominator refers to the distances of all model members for the combination of diagnostic and variable, a.  Note: it doesn't matter if you first average the distances (d^prime a_i), to get one value per model and normalize then or normalize first and average then (given that the normalization is in both cases the median across all models and members).","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"That is, we get a generalized distance value D_i for every model i, respectively values S_ij for every pair of models ij.","category":"page"},{"location":"weights/#Computation-of-overall-weight-for-model-i","page":"Computing weights","title":"Computation of overall weight for model i","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The generalized distances between models and observations, respectively between model pairs are then combined as follows to yield one weight value for each model i (w_i's are normalized by sum_i w_i):","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w_i = frace^-(fracD_isigma_D)^21 + sum_j ne i e^-left( fracS_ijsigma_S right)^2","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The parameters, sigma_D and sigma_S, are free parameters that Brunner et al. estimated using perfect model tests.","category":"page"},{"location":"weights/#Computation-of-performance/independence-weights-only","page":"Computing weights","title":"Computation of performance/independence weights only","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"When computing only performance weights, we assume that all models are equally dependent:","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w^P_i = frace^-(fracD_isigma_D)^2N","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"When computing only independence weights, we assume that all models perform equally well.","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w^I_i = frac11 + sum_j ne i e^-left( fracS_ijsigma_S right)^2","category":"page"},{"location":"requirements/#Requirements","page":"Requirements","title":"Requirements","text":"","category":"section"},{"location":"requirements/#Preprocessed-data","page":"Requirements","title":"Preprocessed data","text":"","category":"section"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"We assume that you have your preprocessed data ready, so that the data from the different models can be combined, meaning that all models must for instance  have the same grid. We do the preprocessing of the data with ESMValTool. A set of recipes to  download and preprocess some data can be found in our repository ESMDataPrep.","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"The structure of the directories where the preprocessed data is stored is expected by our tool to follow a certain structure. If there is one subdirectory for each climate variable (this is, for instance, the case when one ESMValTool recipe is used for a single variable), the structure should be as outline below.  Uppercase names refer to variables, lowercase names mean that the names can be arbitrary, unless stated differently in the comments to the right. ","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"├── BASE_DIR\n│   └── subdir1  # name must contain \"_\" + the short_name of the variable, e.g. _tos\n│   └── subdir2  # name must contain \"_\" + the short_name of the variable, e.g. _tos\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # the name of the diagnostic in ESMValTool, e.g. historical\n│       │      │       └── VAR_STATISTIC    # e.g. tos_CLIM\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # the name of the diagnostic in ESMValTool, e.g. historical1\n│       │      │       └── VAR_STATISTIC    # e.g. tos_STD\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── possibly other output from ESMValTool\n....","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"The structure is basically the same if there is not a seperate subdirectory for each climate variable, except that the BASE_DIR refers to the directory that immediately contains the preproc-subdirectory: ","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"├── BASE_DIR\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # the name of the diagnostic in ESMValTool, e.g. historical\n│       │      │       └── VAR_STATISTIC # e.g. tos_CLIM\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # the name of the diagnostic in ESMValTool, e.g. historical1\n│       │      │       └── VAR_STATISTIC # e.g. tos_STD\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── possibly other output from ESMValTool\n....","category":"page"},{"location":"requirements/#Config-files","page":"Requirements","title":"Config files","text":"","category":"section"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"Further, to load the data, we need one or more yaml configuration files. From these, we retrieve which combination of variables, statistics, aliases, experiments and timeranges will be considered.","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"Since we use ESMValTool to preprocess the data, we can simply use our  ESMValTool recipes (the fully spelled out version output by ESMValTool, which is stored in the run-folder and has the name of recipe + \"filled.yml\") as  config files here. Note that not everything in the recipes is actually needed  for loading the data. For a minimal example with the unnecessary sections  removed, see [this example](https://github.com/awi-esc/SimilarityWeights/blob/main/configs/examples/esmvaltool-recipes/mweesmvaltool_config.yml). ","category":"page"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"You may have one centralized directory, where you store the all yaml files (i.e., if you used ESMValTool, all recipes used for preprocessing the data).","category":"page"},{"location":"examples/lgm/#Weights-for-models-of-lgm-experiment","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"","category":"section"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"First, we want to load all CMIP5 and CMIP6 model data for the lgm-experiment.","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"# points to directory where preprocessed data is stored\npath_data = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/LGM\";\n# point to directory where config files are stored\npath_recipes = \"/albedo/home/brgrus001/SimilarityWeights/configs/lgm-cmip5-cmip6\";\n\nlgm_data = mw.loadDataFromESMValToolConfigs(\n    path_data, path_recipes;\n    dir_per_var = true, # default: true\n    is_model_data = true, # default: true \n    only_shared_models = true, # default: false\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"lgm\"],\n        projects = [\"CMIP5\", \"CMIP6\"],\n        models = Vector{String}(),\n        subdirs = [\"20241114\"]\n    ),\n    preview = false # default value is false\n);\nmodel_members_lgm = Array(dims(first(values(lgm_data)), :member))","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"Then, we load data from the same models for the historical experiment:","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"base_path = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/historical/\";\nconfig_path = \"/albedo/home/brgrus001/SimilarityWeights/configs/historical\";\nhistorical_data = mw.loadDataFromESMValToolConfigs(\n    base_path, config_path;\n    only_shared_models = true,\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"historical\"],\n        timeranges = [\"full\"],\n        models = model_members_lgm,\n        subdirs = [\"20241121\", \"20241118\"]\n    )\n);\n````\n\nThis is the resulting data:","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"julia","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"\nWe could also have used a single yaml configuration file independent of the ESMValTool recipes and load the data all together one:\n\n","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"julia","category":"page"},{"location":"examples/lgm/#Load-model-data-for-experiment-lgm-and-historical-in-one-run-from-new-config-file","page":"Weights for models of lgm experiment","title":"Load model data for experiment lgm and historical in one run from new config file","text":"","category":"section"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"pathconfig = \"/albedo/work/projects/pforclima/preprocdataesmvaltool/configs-SimilarityWeights/example-lgm-historical.yml\";","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"modeldata = mw.loadDataFromYAML(     pathconfig;     dirpervar = true, # default: true     ismodeldata = true, # default: true     onlysharedmodels = true, # default: false     preview = false ); ```","category":"page"},{"location":"examples/lgm/#TODO:-show-that-we-get-the-same-outfit-different-approaches!","page":"Weights for models of lgm experiment","title":"TODO: show that we get the same outfit different approaches!","text":"","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is twofold: on the one hand, we built it to handle preprocessed Earth System data easily within Julia and, on the other hand, to compute weights for different sets of Earth System Models following the approach from Brunner et al (2020).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main objects that the package provides are: DataMap and two weight  objects, ConfigWeights and Weights.","category":"page"},{"location":"#DataMap-Object","page":"Home","title":"DataMap Object","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each Data object refers to some summary data (e.g. climatological average)  of a particular experiment for the full time period or part of it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DataMap is a type alias for a dictionary mapping from Strings to YAXArrays. The metadata of each dataset (datamapidproperties) contains the  metadata loaded from the original files as well as some additional information  that we add: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"_variable\n_statistic\n_alias\n_timerange\n_paths\n_id: concatenates variable, statistic and alias into a single String ","category":"page"},{"location":"","page":"Home","title":"Home","text":"separated by underscores","category":"page"},{"location":"#Weight-Objects","page":"Home","title":"Weight Objects","text":"","category":"section"},{"location":"#ConfigWeights","page":"Home","title":"ConfigWeights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import ModelWeights as mw\n\n# load model and observational data\n\nconfig_weights = mw.ConfigWeights(\n    performance = Dict(\"tas_CLIM\" => 1, \"tos_CLIM\" => 1),\n    independence = Dict(\"tas_CLIM\" => 1, \"tos_CLIM\" => 1),\n    sigma_performance = 0.5,\n    sigma_independence = 0.5,\n    alias_ref_perform_weights = \"historical\",\n    alias_ref_indep_weights = \"historical\",\n    target_path = \"\"\n);","category":"page"},{"location":"#Weights","page":"Home","title":"Weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"weights = mw.computeWeights(model_data_historical, obs_data, config_weights);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Weights object has several fields that each store a DimensionalData.DimArray. Some of them refer to normalized weights, others refer  to the distances on the basis of which the weights were computed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"performance_distances and independence_distances contain the distances","category":"page"},{"location":"","page":"Home","title":"Home","text":"between models and data (performance) or between models and models (independence)  for every combination of variable and diagnostic/statistic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Di and Sij are the generalized distances, i.e. weighted average of all","category":"page"},{"location":"","page":"Home","title":"Home","text":"distances across variables and diagnostic. So, D_i is a vector with size  1xn where n is the number of models (not on level of members!) and S_ij is  a matrix of size n x n. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"wP and wI respectively store the normalized performance/independence weights, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"both have size 1xn (n: number of models).","category":"page"},{"location":"","page":"Home","title":"Home","text":"w is the overall weight vector of length n.","category":"page"},{"location":"#Application-of-weights","page":"Home","title":"Application of weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO: add example of how weights are applied to data","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"#ModelWeights.addAnomalies!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, String, String}","page":"Home","title":"ModelWeights.addAnomalies!","text":"addAnomalies!(\n    datamap::DataMap id_data::String, id_ref::String; stats::String=\"ANOM\"\n)\n\nAdd entry to datamap with difference between datamap at id_data and id_ref.\n\nThe id of the original data and of the reference data is added to the metadata.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addAnomaliesGM!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Home","title":"ModelWeights.addAnomaliesGM!","text":"addAnomaliesGM!(data::DataMap, ids_data::Vector{String})\n\nCompute anomalies of datasets in data with ids in ids_data with respect to  their global means.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addDiagnostic!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Function, String, Vararg{Any}}","page":"Home","title":"ModelWeights.addDiagnostic!","text":"addDiagnostic!(datamap::DataMap, fn::Function, args...; kwargs...)\n\nCompute a diagnostic by running fn with positional arguments args and  keyword arguments kwargs and add result to datamap at the id of the  computed result.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addGlobalMeans!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.addGlobalMeans!","text":"addGlobalMeans!(data::DataMap; ids::Union{Vector{String},Nothing})\n\nCompute global means for datasets in data with ids.\n\nIf ids is not specified, compute global means for all datasets in data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addLinearTrend!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.addLinearTrend!","text":"addLinearTrend!(\n    data::DataMap;     \n    statistic::String=\"CLIM-ann\", \n    ids_ts::Vector{String}=Vector{String}(), \n    full_predictions::Bool=true\n)\n\nAdd computed linear trend (computeLinearTrend) for all datasets in data with an  id in ids_ts, or if ids_ts is not given for all datasets with statistic  (as specified in metadata _statistic), where the default is the annual  climatologies (CLIM-ann).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addPathsToMetaAttribs!-Tuple{Dict{String, Any}, String, Bool, Bool}","page":"Home","title":"ModelWeights.addPathsToMetaAttribs!","text":"addPathsToMetaAttribs!(\n    attrib::Dict{String, Any},\n    base_path_data::String,\n    dir_per_var::Bool,\n    is_model_data::Bool;\n    constraint::Union{Dict, Nothing}=nothing\n)\n\nCreate a metadata Dictionary with the information from attrib and the file paths to the data files in base_path_data taking into account constraint.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.addTempSTD!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.addTempSTD!","text":"addTempSTD!(data::DataMap; statistic::String=\"CLIM-ann\")\n\nCompute temporal standard deviation (computeTempSTD) for every dataset with  statistic in its id (default: CLIM-ann) and add the result to data. \n\nThe id of computed temporal standard deviation is the same as before, but with  statistic replaced by 'TREND'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.alignPhysics-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Home","title":"ModelWeights.alignPhysics","text":"alignPhysics(\n    data::DataMap,\n    members::Vector{String}, \n    subset_shared::Union{LEVEL, Nothing} = nothing)\n)\n\nReturn new DataMap with only the models retained that share the same physics as  the respective model's members in members.\n\nIf subset_shared is set, resulting DataMap is subset accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.applyDataConstraints!-Tuple{Vector{Dict{String, Any}}, Dict}","page":"Home","title":"ModelWeights.applyDataConstraints!","text":"applyDataConstraints!(meta_attributes::Vector{Dict{String, Any}}, constraint::Dict)\n\nSubset entries in meta_attributes so that only those with properties specified  in constraint remain.\n\nArguments\n\nconstraint::Dict: Mapping to vector specifiying the properties of which at \n\nleast one must be present for an id to be retained.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.applyModelConstraints-Tuple{String, Vector{String}}","page":"Home","title":"ModelWeights.applyModelConstraints","text":"applyModelConstraints(\n    path_model_data::String, model_constraints::Vector{String}\n)\n\nReturn true if constraints in model_constraints are fulfilled, i.e. if the  given path_model_data contains any model from model_constraints, false  otherwise.\n\nArguments:\n\nmodel_constraints: strings that may contain only model name, e.g. 'MPI-ESM-P', \n\nor modelname and member id, e.g. 'MPI-ESM-P#r1i1p2' or model name, member id and  grid, e.g. 'MPI-ESM-P#r1i1p2gn'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.applyWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.applyWeights","text":"applyWeights(model_data::YAXArray, weights::YAXArray)\n\nCompute the weighted average of model data 'data' with given weights 'weights'.\n\nIf weights were computed for a superset of the models in 'data', they are normalized and applied to the subset. Only weights per model (not members) are considered for now, in the future, members should be considered too.\n\nArguments:\n\nmodel_data::YAXArray: model predictions. If given for model members, the predictions \n\nof each model are considered the average value of all members of the respective model.\n\nweights::YAXArray: if given for each member of a model, these will be summed up to \n\nyield one value per model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.approxAreaWeights-Tuple{Vector{<:Number}}","page":"Home","title":"ModelWeights.approxAreaWeights","text":"approxAreaWeights(latitudes::Vector{<:Number})\n\nCreate a YAXArray with the cosine of latitudes which approximates the cell  area on the respective latitude.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.areaWeightedRMSE-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"Home","title":"ModelWeights.areaWeightedRMSE","text":"areaWeightedRMSE(m1::AbstractArray, m2::AbstractArray, mask::AbstractArray)\n\nCompute the area weighted (approximated by cosine of latitudes in radians)  root mean squared error between m1 and m2. \n\nArguments:\n\nm1: must have dimensions 'lon', 'lat'.\nm2: must have dimensions 'lon', 'lat'.\nmask: has values 0,1. Locations where mask is 1 get a weight of 0.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.averageEnsembleMembersMatrix-Tuple{YAXArrays.Cubes.YAXArray, Bool}","page":"Home","title":"ModelWeights.averageEnsembleMembersMatrix","text":"averageEnsembleMembersMatrix(data::AbstractArray, updateMeta::Bool)\n\nCompute the average across all members of each model for each given variable  for model to model data, e.g. distances between model pairs.\n\nArguments:\n\ndata: with at least dimensions 'member1', 'member2'\nupdateMeta: set true if the vectors in the metadata refer to different models. \n\nSet to false if vectors refer to different variables for instance. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.buildCMIP5EnsembleMember-Tuple{Vector, Vector, Vector}","page":"Home","title":"ModelWeights.buildCMIP5EnsembleMember","text":"buildCMIP5EnsembleMember(\n    realizations::Vector, initializations::Vector, physics::Vector\n)\n\nConcatenate model settings to build ripf-abbreviations for CMIP5 models which  do not have it in their metadata. Return a vector of strings.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.buildPathsForMetaAttrib-Tuple{String, Dict{String, Any}, Bool}","page":"Home","title":"ModelWeights.buildPathsForMetaAttrib","text":"buildPathsForMetaAttrib(\n    base_path::String, \n    attrib::MetaAttrib,\n    dir_per_var::Bool;\n    subdir_constraints::Union{Vector{String}, Nothing}=nothing\n)\n\nArguments:\n\nbase_path: base directory of stored data specified in attrib.\nattrib: meta attributes of data.\ndir_per_var: true if data of each climate variable is stored in a seperate directory.\nsubdir_constraints: if given, paths must contain ANY of the given elements. Existing paths that don't are ignored.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.buildPathsToDataFiles-Tuple{String, Bool}","page":"Home","title":"ModelWeights.buildPathsToDataFiles","text":"buildPathsToDataFiles(\n    path_data::String,\n    is_model_data::Bool;\n    model_constraints::Vector{String} = Vector{String}(),\n    project_constraints::Vector{String} = Vector{String}()\n)\n\nBuild vector of strings containing paths to data files in path_data  that were not filtered out by model_constraints or project_constraints.\n\nArguments:\n\nmodel_constraints::Vector{String}:\nproject_constraints::Vector{String}:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeDistancesAllDiagnostics-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Union{Nothing, Dict{String, YAXArrays.Cubes.YAXArray}}, Dict{String, Number}, String, Bool}","page":"Home","title":"ModelWeights.computeDistancesAllDiagnostics","text":"computeDistancesAllDiagnostics(\n    model_data::DataMap, \n    obs_data::Union{Nothing, DataMap}, \n    config::Dict{String, Number},\n    ref_period_alias::String,\n    forPerformance::Bool    \n)\n\nCompute RMSEs between models and observations or between predictions of models  for all variables and diagnostics for which weights are specified in config.\n\nArguments:\n\nconfig::Dict{String, Number}: mapping from 'VARIABLE_DIAGNOSTIC' to \n\nrespective weight.\n\nfor_performance::Bool: true for distances between models and observations, \n\nfalse for distances between model predictions.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeGeneralizedDistances-Tuple{YAXArrays.Cubes.YAXArray, DimensionalData.DimArray, Bool}","page":"Home","title":"ModelWeights.computeGeneralizedDistances","text":"computeGeneralizedDistances(\n    distances_all::YAXArray, weights::DimArray, for_performance::Bool\n\n)\n\nFor every variable in distances_all, compute the weighted sum of all  diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeGlobalMeans-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.computeGlobalMeans","text":"computeGlobalMeans(data::AbtractArray)\n\nReturn a YAXArray with area-weighted global means for each model in data. \n\nMissing data is accounted for in the area-weights. \n\nArguments:\n\ndata::YAXArray: must have dimensions 'lon' and 'lat'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeInterpolatedWeightedQuantiles-Tuple{Vector{<:Number}, Vector}","page":"Home","title":"ModelWeights.computeInterpolatedWeightedQuantiles","text":"computeInterpolatedWeightedQuantiles(\n    quantiles::Vector{<:Number}, vals::Vector; weights=nothing    \n)\n\nThis implementation follows the one used by Brunner et al.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeLinearTrend-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.computeLinearTrend","text":"computeLinearTrend(data::YAXArray; full_predictions::Bool=true)\n\nCompute linear trend as ordinary least squares for timeseries data.\n\nArguments:\n\ndata::YAXArray: must have dimension :time.\nfull_predictions::Bool: if false, return only slope, otherwise return \n\npredicted value.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeModelDataRMSE-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Dict{String, YAXArrays.Cubes.YAXArray}, ModelWeights.ConfigWeights}","page":"Home","title":"ModelWeights.computeModelDataRMSE","text":"computeModelDataRMSE(\n    model_data::DataMap, obs_data::DataMap, config::ConfigWeights    \n)\n\nCompute the Root-mean-squared-error between model_data and obs_data for  each combination of variable and diagnostic for which weights > 0 are specified  in config.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeModelModelRMSE-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, ModelWeights.ConfigWeights}","page":"Home","title":"ModelWeights.computeModelModelRMSE","text":" computeModelModelRMSE(model_data::DataMap, config::ConfigWeights)\n\nCompute the Root-mean-squared-error between pairs of models in model_data for   each combination of variable and diagnostic for which weights > 0 are specified  in config.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeTempSTD-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.computeTempSTD","text":"computeTempSTD(data::YAXArray, trend::YAXArray)\n\nCompute the standard deviation of the temporal detrended timeseries data as  STD^{t2}t=t1 (Xl^t) - X_l^{TREND} where l is a (lon, lat)-position and  TREND is the prediction of the ordinary least squares fit of the data (i.e.  trend must have the same size as data).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeWeightedAvg-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.computeWeightedAvg","text":"computeWeightedAvg(\n    data::YAXArray; \n    weights::Union{DimArray, Nothing}=nothing,\n    use_members_equal_weights::Bool=true\n)\n\nCompute the average values for each (lon,lat) grid point in 'data', weighted by weights 'weights'. If no weight vector is provided, unweighted average is computed.\n\nArguments:\n\ndata: must have dimension 'model' or 'member'\nweights: weights for models or individual members\nuse_members_equal_weights:  if weights is nothing, all models receive \n\nequal weight. If use_members_equal_weights is true, the number of members  per model is taken into account, s.t. each model receives equal weight, which is distributed among the respective members.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.computeWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, ModelWeights.ConfigWeights}","page":"Home","title":"ModelWeights.computeWeights","text":"computeWeights(\n    dists_indep_all::YAXArray, \n    dists_perform_all::YAXArray,\n    config::ConfigWeights\n)\n\nCompute weight for each model in multi-model ensemble according to approach from Brunner, Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020. \n\nArguments:\n\ndists_indep_all::YAXArray: RMSEs between pairs of models for all \n\ncombinations of variables and diagnostics; has dimensions 'member1', 'member2',  'variable', 'diagnostic'.\n\ndists_perform_all::YAXArray: RMSEs between model and observational \n\ndata for all combinations variables and diagnostics; has dimensions 'member',  'variable', 'diagnostic'.\n\nconfig::ConfigWeights: Parameters specifiying the relative contributions \n\nof each combination of variable and diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.convertKgsToSv!-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.convertKgsToSv!","text":"convertKgsToSv!(vec:YAXArray)\n\nConvert data given in unit 'kg s-1' into Sverdrups (Sv).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.distributeWeightsAcrossMembers-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.distributeWeightsAcrossMembers","text":"distributeWeightsAcrossMembers(weights::YAXArray, members::Vector{String})\n\nEqually distribute weight for each model over its members.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.filterModels-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.filterModels","text":"filterModels(data::YAXArray, remaining_models::Vector{String})\n\nRemove models from data that aren't in remaining_models and adapt the  metadata of data accordingly such that 'membernames' and 'modelnames'  corresponds to the remaining data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.filterPaths-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"ModelWeights.filterPaths","text":"filterPaths(paths::Vector{String}, shared_models::Vector{String})\n\nReturn new vector with paths in paths that point to models in shared_models.\n\nArguments:\n\nshared_models: have form 'modelname#memberID[_grid]' on level of model\n\nmembers or just 'modelname' on level of models.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.filterPathsSharedModels!-Tuple{Dict{String, Dict{String, Any}}, Union{Nothing, ModelWeights.LEVEL}}","page":"Home","title":"ModelWeights.filterPathsSharedModels!","text":"filterPathsSharedModels!(\n    meta_data::Dict{String, Dict{String, Any}},\n    subset_shared::Union{LEVEL, Nothing}\n)\n\nIn particular important before loading data if data should be subset\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.filterTimeseries-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Number, Number}","page":"Home","title":"ModelWeights.filterTimeseries","text":"filterTimeseries(\n    data_all::DataMap, \n    start_year::Number, \n    end_year::Number;\n    new_alias::String=\"\",\n    ids_ts::Vector{String}=Vector{String}(),\n    only_models_non_missing_vals::Bool = true\n)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getAliasAsTimerange-Tuple{Vector{Dict{String, Any}}, String}","page":"Home","title":"ModelWeights.getAliasAsTimerange","text":"getAliasAsTimerange(meta_attribs::Vector{MetaAttrib}, alias::String)\n\nTranslate each alias in meta_attribsto corresponding timerange.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getAllCombinations-Tuple","page":"Home","title":"ModelWeights.getAllCombinations","text":"getAllCombinations(v...)\n\nGenerate vector of strings with all possible combinations of input vectors, where each combination consists of one element from each input vector,  concatenated as a string with underscores separating the elements.\n\nArguments\n\nv...: A variable number of input vectors.\n\nExample\n\njulia> ModelWeights.getAllCombinations([\"tos\", \"tas\"], [\"CLIM\"])\n2-element Vector{String}:\n \"tos_CLIM\"\n \"tas_CLIM\"\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getAtModel-Tuple{AbstractArray, Symbol, String}","page":"Home","title":"ModelWeights.getAtModel","text":"getAtModel(data::AbstractArray, dimension::Symbol, model::String)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getByIdxModel-Tuple{AbstractArray, Symbol, Vector}","page":"Home","title":"ModelWeights.getByIdxModel","text":"getByIdxModel(data::AbstractArray, dimension::Symbol, indices::Vector)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getCMIPModelsKey-Tuple{Dict}","page":"Home","title":"ModelWeights.getCMIPModelsKey","text":"getCMIPModelsKey(meta::Dict)\n\nReturn the respective key to retrieve model names in CMIP6 ('sourceid') and  CMIP5 ('modelid') data.\n\nIf both keys are present, 'source_id' used in CMIP6 models is returned, if none  is present, throw ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getClosestGridPoint-Tuple{Dict, Vector, Vector}","page":"Home","title":"ModelWeights.getClosestGridPoint","text":"getClosestGridPoint(location::Dict, longitudes::Vector, latitudes::Vector)\n\nFind the grid point in grid defined by longitudes and latitudes that is closest to location.\n\nArguments\n\nlocation::Dict: 'lon', 'lat' of position for which closest grid point is\n\nreturned, lon must be given from -180° to 180°\n\nlongitudes::Vector: grid longitudes measured from -180° to 180°\nlatitudes::Vector: grid latitudes measured from -90° to 90°\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getDimsModel-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.getDimsModel","text":"getDimsModel(data::AbstractArray)\n\nReturn Tuple with the model dimension of data ('model' or 'member') as Symbol at position 1 and the respetive dimension names at position 2.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getMemberIDsFromPaths-Tuple{Vector{String}}","page":"Home","title":"ModelWeights.getMemberIDsFromPaths","text":"getMemberIDsFromPaths(all_paths::Vector{String})\n\nFor every path in all_paths return a string of the form modelname#memberID[_grid] that identifies the corresponding model member.\n\nThe abbreviation of the grid is added to the model name for CMIP6 models.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getMetaAttributesFromESMValToolConfigs-Tuple{String}","page":"Home","title":"ModelWeights.getMetaAttributesFromESMValToolConfigs","text":"getMetaAttributesFromESMValToolConfigs(\n    base_path_configs::String;\n    constraint::Union{Dict, Nothing} = nothing\n\n)\n\nRead variable, statistic, experiment and timerange/alias values from ESMValTool  recipes stored at base_path_configs into a vector of Dictionaries storing the  respective readoff values.\n\nIf constraint is given, a combination of 'statistic', 'experiment', etc. is  only retained if each of the respective readoff values aligns with the the specified constraints if provided.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getMetaDataFromYAML-Tuple{Dict, Bool}","page":"Home","title":"ModelWeights.getMetaDataFromYAML","text":"getMetaDataFromYAML(\n    path_config::String,\n    is_model_data::Bool\n    subset::Union{Dict, Nothing} = nothing\n)\n\nLoad data as specified in config file located at path_config. For constraints that are specified in the config file as well as in the arg_constraint argument,  the values of the latter have precedence over the former. The constraints given in the argument subset are applied to EVERY dataset specified in the config  file.\n\nArguments:\n\npath_config: path to config yaml file specifying meta attributes and paths of data\nis_model_data: true for model data, false for observational data\narg_constraint: TODO\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getModelDataDist-Tuple{YAXArrays.Cubes.YAXArray, AbstractArray}","page":"Home","title":"ModelWeights.getModelDataDist","text":"getModelDataDist(models::YAXArray, observations::AbstractArray)\n\nCompute the distance as the area-weighted RMSE between model predictions and  observations. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getModelDistances-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.getModelDistances","text":"getModelDistances(modelData::YAXArray)\n\nCompute the area weighted root mean squared error between model predictions  for each pair of models.\n\nArguments:\n\nmodelData::YAXArray: must have dimensions 'lon', 'lat', 'model' and \n\ncontains the data for a single climate variable.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getModelLogLikelihoods-Tuple{YAXArrays.Cubes.YAXArray, Distributions.Distribution}","page":"Home","title":"ModelWeights.getModelLogLikelihoods","text":"getModelLogLikelihoods(model_data::YAXArray, distr::Distribution)\n\nCompute the log likelihood of model_data to originate from distr.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getRefPeriodAsTimerangeAndAlias-Tuple{Vector{Dict{String, Any}}, String}","page":"Home","title":"ModelWeights.getRefPeriodAsTimerangeAndAlias","text":"getRefPeriodAsTimerangeAndAlias(\n    meta_attribs::Vector{MetaAttrib}, ref_period::String\n)\n\nReturn timerange and alias corresponding to ref_period which can be either be  a timerange or an alias.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getSharedModelsFromPaths-Tuple{Vector{Vector{String}}, Vector{String}}","page":"Home","title":"ModelWeights.getSharedModelsFromPaths","text":"getSharedModelsFromPaths(\n    all_paths::Vector{Vector{String}}, all_models::Vector{String}\n)\n\nReturn vector with those models in 'allmodels' for which a path is given in  every subvector of 'metadata'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getTimerangeAsAlias-Tuple{Vector{Dict{String, Any}}, String}","page":"Home","title":"ModelWeights.getTimerangeAsAlias","text":"getTimerangeAsAlias(meta_attribs::Vector{MetaAttrib}, timerange::String)\n\nTranslate given timerange to corresponding alias in data_ids.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getUncertaintyRanges-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.getUncertaintyRanges","text":"getUncertaintyRanges(\n    data::AbstractArray; \n    w::Union{DimArray, Nothing}=nothing, \n    quantiles=[0.167, 0.833]}\n)\n\nCompute weighted quantiles of data.\n\nArguments:\n\ndata::AbstractArray: must have dimensions 'time', 'model'.\nw::Union{DimArray, Nothing}=nothing: must have dimension 'model' and sum up to 1.\nquantiles=[0.167, 0.833]: vector with two entries between 0 and 1 \n\nrepresenting  the lower and upper bound in this order.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.getUniqueMemberIds-Tuple{Dict, Vector{String}}","page":"Home","title":"ModelWeights.getUniqueMemberIds","text":"getUniqueMemberIds(meta::Dict, model_names::Vector{String})\n\nCreate a vector that contains for every model in model_names the unique ids of its members, each with the model name followed by '#' as prefix .\n\nThe unique member ids correspond to the variant labels of CMIP6 models, e.g. r1i1p1f1.\n\nArguments:\n\nmeta::Dict: For CMIP5 data, must have keys: 'mip_era', 'realization',\n\n'initializationmethod', 'physicsversion'. For CMIP6 data must have keys:  'variantlabel', 'gridlabel'.\n\nmodel_names::Vector{String}: Vector of strings containing model names for \n\nevery model member, i.e. length is sum of the number of members over all models.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.get_optional_fields_config-Tuple{Dict, Dict}","page":"Home","title":"ModelWeights.get_optional_fields_config","text":"get_optional_fields_config(ds::Dict, timerange_aliases_dict::Dict)\n\nFill optional fields for a dataset in config file with default values.  Returned timeranges and aliases have the same length and correspond to one another.\n\nArguments:\n\nds:\ntimerange_aliases_dict:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.independenceParts-Tuple{AbstractArray, Number}","page":"Home","title":"ModelWeights.independenceParts","text":"independenceParts(generalizedDistances::AbstractArray, sigmaS::Number)\n\nCompute the independence part (denominator) of the overall weight for each model.\n\nArguments:\n\ngeneralizedDistances: contains generalized distances S_{i,j} for each model \n\n(i.e. not model members) pair has two dimensions, 'model1' and 'model2'\n\nsigmaS: free model parameter for impact of independence weights\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.isValidDataAndWeightInput-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}, String}","page":"Home","title":"ModelWeights.isValidDataAndWeightInput","text":"isValidDataAndWeightInput(\n    data::DataMap, keys_weights::Vector{String}, ref_period_alias::String\n)\n\nCheck that there is data in data for all keys_weights containing weights  balancing the different diagnostics for the given reference period  ref_period_alias.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.joinDataMaps-Tuple{Vararg{Dict{String, YAXArrays.Cubes.YAXArray}}}","page":"Home","title":"ModelWeights.joinDataMaps","text":"joinDataMaps(v::DataMap...)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.kelvinToCelsius!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.kelvinToCelsius!","text":"kelvinToCelsius!(datamap::DataMap)\n\nModify entries of datamap such that all data is given in Degree Celsius (instead)  of Kelvin.\n\nArguments:\n\ndatamap:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.kelvinToCelsius-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.kelvinToCelsius","text":"kelvinToCelsius(data::AbstractArray)\n\nReturn a copy of data with values given in Kelvin covnerted into Degree Celsius.\n\nArguments:\n\ndata:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.latitude2NorthSouth-Tuple{Number}","page":"Home","title":"ModelWeights.latitude2NorthSouth","text":"latitude2NorthSouth(lat::Number)\n\nConvert latitudes from -90° to 90° into 0° to 90° North/South.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadData-Tuple{Dict}","page":"Home","title":"ModelWeights.loadData","text":"loadData(\n    content::Dict;\n    is_model_data::Bool=true,\n    subset::Union{Dict, Nothing}=nothing,\n    preview::Bool=false\n)\n\nLoad a DataMap-instance that contains the data specified in content.\n\nArguments:\n\ncontent::Dict: see TODO:add link to documentation?! for required keys.\nis_model_data::Bool: true for model data (default), false for observational data.\nsubset: specifies the properties of the subset of data to be loaded. These \n\nhave to apply to each loaded dataset specified in the config yaml file.  The following keys are considered:  models (used to load only specific set of models  or members of models), projects (used to load only data from a given set of projects, e.g. for loading only CMIP5-data), timeranges and aliases  (super set is loaded, i.e. all data that corresponds to either a given timerange or a given alias will be loaded), variables, statistics, subdirs, subset_shared  (if set to MEMBER/MODEL only data loaded from model members/models shared across all datasets is loaded) and dir_per_var.\n\npreview::Bool: if true (default: false), return metadata without actually \n\nloading any data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadData-Tuple{String}","page":"Home","title":"ModelWeights.loadData","text":"loadData(\n    path_config::String;\n    is_model_data::Bool=true,\n    subset::Union{Dict, Nothing}=nothing,\n    preview::Bool=false\n)\n\nLoad a DataMap-instance that contains the data specified in yaml file at  path_config.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadDataFromESMValToolRecipes-Tuple{String, String}","page":"Home","title":"ModelWeights.loadDataFromESMValToolRecipes","text":"loadDataFromESMValToolRecipes(\n    path_data::String,\n    path_recipes::String;\n    dir_per_var::Bool=true,\n    is_model_data::Bool=true,\n    subset::Union{Dict, Nothing}=nothing,\n    preview::Bool=false\n)\n\nLoads the data from the config files (ESMValTool recipes) located at 'path_recipes'. For each variable, experiment, statistic and timerange (alias), an instance of Data is created.\n\nArguments:\n\npath_data:  path to location where preprocessed data is stored; if \n\ndirpervar is true, paths to directories that contain one or more subdirectories that each contains a directory 'preproc' with the preprocessed data. If dirpervar is false, path_data is path to directory that  directly contains the 'preproc' subdirectory.\n\npath_recipes: path to directory that contains one or ESMValTool recipes \n\nused as config files.\n\ndir_per_var: if true, directory at path_data has subdirectories, one for\n\neach variable (they must end with _ and the name of the variable), otherwise data_path points to the directory that has a subdirectory 'preproc'.\n\nis_model_data: set true for model data, false for observational data\nsubset: specifies the properties of the subset of data to be loaded. \n\nThe following keys are considered:  models (used to load only specific set of models  or members of models), projects (used to load only data from a given set of projects, e.g. for loading only CMIP5-data), timeranges and aliases. (super set is loaded, i.e. data that corresponds to either a given timerange or a given alias will be loaded), variables, statistics, subdirs and subset_shared . (if set to MEMBER/MODEL only data loaded from model members/models shared across all experiments and variables is loaded).\n\npreview: used to pre-check which data will be loaded before actually loading\n\nit. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadDataFromMetadata-Tuple{Dict{String, Dict{String, Any}}, Bool}","page":"Home","title":"ModelWeights.loadDataFromMetadata","text":"loadDataFromMetadata(\n    meta_data::Dict{String, Dict{String, Any}}, is_model_data::Bool\n)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadPreprocData-Tuple{Dict{String, Any}, Bool}","page":"Home","title":"ModelWeights.loadPreprocData","text":"loadPreprocData(meta::Dict{String, Any}, is_model_data::Bool)\n\nCreate a tuple with a vector of YAXArrays for data specified in meta and a  Dictionary containing the metadata of all loaded data. \n\nLoad the data from paths specified in meta.paths and create a meta dictionary that contains the metadata keys from every loaded dataset. Each key maps to a vector  of values, one for each loaded dataset, which is set to missing if that key  hadn't been present in this datasets own metadata.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.loadWeightsAsDimArray-Tuple{NCDatasets.NCDataset, String}","page":"Home","title":"ModelWeights.loadWeightsAsDimArray","text":"loadWeightsAsDimArray(data::NCDataset, key_weights::String)\n\nArguments:\n\ndata: NCDataset containing weights, which have a single dimension\nkey_weights: name of weights to load; 'wP' (performance weights), 'wI'\n\n(independence weights), 'w' (overall weights)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.lon180to360-Tuple{Number}","page":"Home","title":"ModelWeights.lon180to360","text":"lon360to180(lon::Number)\n\nConvert longitudes measured from -180° to 180° into 0° to 360° scale.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.lon360to180-Tuple{Number}","page":"Home","title":"ModelWeights.lon360to180","text":"lon360to180(lon::Number)\n\nConvert longitudes measured from 0° to 360° into  -180° to 180° scale.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.longitude2EastWest-Tuple{Number}","page":"Home","title":"ModelWeights.longitude2EastWest","text":"longitude2EastWest(lon::Number)\n\nConvert longitudes from -180° to 180° into 0° to 180° East/West.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.makeEqualWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.makeEqualWeights","text":"makeEqualWeights(data::YAXArray; use_members::Bool=true)\n\nCreate a weight vector, with equal weight for each MODEL. Distribute weight across model members if dimension=:member and usemembers is true. If usemember is false,  each model member is considered as standalone model and all receive the same weight.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.makeSubplots-Tuple{AbstractArray, @NamedTuple{nrows::Int64, ncols::Int64}}","page":"Home","title":"ModelWeights.makeSubplots","text":"makeSubplots\n\nArguments:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.mergeLoadedData-Tuple{Vector{YAXArrays.Cubes.YAXArray}, Dict{String, Any}, Bool}","page":"Home","title":"ModelWeights.mergeLoadedData","text":"mergeLoadedData(\n    data_vec::Vector{YAXArray}, \n    meta_dict::Dict{String, Any}, \n    is_model_data::Bool\n)\n\nAll data is assumed to be defined on the same grid.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.mergeMetaDataPaths-Tuple{Dict{String, Any}, Dict{String, Any}}","page":"Home","title":"ModelWeights.mergeMetaDataPaths","text":"mergeMetaDataPaths(meta1::Dict{String, Any}, meta2::Dict{String, Any})\n\nReturn vector of unique paths of mergee set of paths from meta1 and meta2.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.normalizeWeightsVariables-Tuple{Dict{String, Number}}","page":"Home","title":"ModelWeights.normalizeWeightsVariables","text":"normalizeWeightsVariables(weights_dict::Dict{String, Number})\n\nNormalize weights for combinations of variable and diagnostic such that they  sum up to 1.\n\nArguments:\n\nweights_dict: maps from VARIABLEDIAGNOSTIC (e.g. tasCLIM) to weights\n\nReturn:\n\nDimArray with dimensions 'variable' and 'diagnostic' containig the normalized  weights.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.performanceParts-Tuple{AbstractArray, Number}","page":"Home","title":"ModelWeights.performanceParts","text":"performanceParts(generalizedDistances::AbstractArray, sigmaD::Number)\n\nCompute the performance part (numerator) of the overall weight for each model.\n\nArguments:\n\ngeneralizedDistances: contains generalized distances Di for each model\nsigmaD: free model parameter for impact of performance weights\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotAMOC-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.plotAMOC","text":"plotAMOC(data::DimArray)\n\nPlot AMOC strength for variable \"amoc\".\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotDistances-Tuple{AbstractArray, String}","page":"Home","title":"ModelWeights.plotDistances","text":"plotDistances(dists::AbstractArray, title::String; is_bar_plot::Bool=true)\n\nPlot figure of distances for every combination of variable and diagnostic in  dists.\n\nArguments:\n\ndists: must have dimensions :variable, :diagnostic\ntitle:\nis_bar_plot:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotDistancesIndependence-Tuple{AbstractArray, String}","page":"Home","title":"ModelWeights.plotDistancesIndependence","text":"plotDistancesIndependence(distances::AbstractArray, dimname::String)\n\nArguments:\n\ndistances:\ndimname:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotEnsembleSpread-Tuple{YAXArrays.Cubes.YAXArray, Number, Number}","page":"Home","title":"ModelWeights.plotEnsembleSpread","text":"plotEnsembleSpread(data::AbstractArray, lon::Number, lat::Number)\n\nCreate figure with boxplots for each model in data that have several ensemble members.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotHistAtPos-Tuple{YAXArrays.Cubes.YAXArray, Dict}","page":"Home","title":"ModelWeights.plotHistAtPos","text":"plotHistAtPos(data::AbstractArray, location::Dict)\n\nPlot histogram of all data for a specific location.\n\nArguments:\n\ndata: dimensions 'lon' (from -180° to 180°), 'lat' (-90° to 90°)\nlocation: must have keys 'name', 'lon', 'lat'\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotTempGraph-Tuple{YAXArrays.Cubes.YAXArray, NamedTuple, NamedTuple, String}","page":"Home","title":"ModelWeights.plotTempGraph","text":"plotTempGraph\n\n# TODO: change quantileLabels and uncertaintyRanges, the latter should contain \n# the quantile labels\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotValsOnMap!-Tuple{Makie.Figure, AbstractArray, String}","page":"Home","title":"ModelWeights.plotValsOnMap!","text":"plotValsOnMap!(fig::Figure, means::AbstractArray, title::String;                     colors=nothing, colorrange=nothing, highclip=(1,0,0),                     lowclip=(0,0,1), pos=(x=1, y=1), poslegend=nothing                     )\n\nPlot contours of world with an overlayed heatmap of the input data.\n\nArguments:\n\nnb_ticks: if nothing (default), just min lat/lon, max lat/lon and 0 are labeled.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotWeightContributions-Tuple{DimensionalData.DimArray, DimensionalData.DimArray}","page":"Home","title":"ModelWeights.plotWeightContributions","text":"plotWeightContributions(independence::DimArray, performance::DimArray)\n\nPlot performance against independence weights.\n\nArguments:\n\nindependence: (dims:model) normalized independence weights\nperformance: (dims:model) normalized performance weights \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.plotWeights-Tuple{ModelWeights.Weights}","page":"Home","title":"ModelWeights.plotWeights","text":"plotWeights(weights::Weights; title::String=\"\")\n\nPlot all weights together, i.e. overall weights, performance-only and  independence-only weights.\n\nArguments:\n\nweights:\ntitle: \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.putAtModel!-Tuple{AbstractArray, Symbol, String, Any}","page":"Home","title":"ModelWeights.putAtModel!","text":"putAtModel!(data::AbstractArray, dimension::Symbol, model::String, input)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.readDataFromDisk-Tuple{String}","page":"Home","title":"ModelWeights.readDataFromDisk","text":"readDataFromDisk(target_path::String; variable::String=\"\")\n\nLoad data from target_path. If target_path ends with '.jld2', variable  must be specified, otherwise  data is assumed to be binary.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.saveWeightsAsNCFile-Tuple{ModelWeights.Weights, String}","page":"Home","title":"ModelWeights.saveWeightsAsNCFile","text":"saveWeightsAsNCFile(weights::Weights; target_path::String)\n\nArguments:\n\nweights: Weights object to be saved.\ntarget_path: Path to where weights shall be stored.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.searchModelInPaths-Tuple{String, Vector{String}}","page":"Home","title":"ModelWeights.searchModelInPaths","text":"searchModelInPaths(model::String, paths::Vector{String})\n\nArguments:\n\nmodel_id::String: has form modelname#memberID[_grid]\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.setLookupsFromMemberToModel-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.setLookupsFromMemberToModel","text":"setLookupsFromMemberToModel(data::YAXArray, dim_names::Vector{String})\n\nChange the lookup values for the dimension 'member' to refer to the models, i.e. they are not unique anymore. This is done in preparation to group the data by the different models.\n\nArguments:\n\ndata::YAXArray: has at least dimensions in dim_names.\ndim_names::Vector{String}: names of dimensions to be changed, e.g. 'member', \n\n'member1' (would be changed to 'model', 'model1').\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.setRefPeriodInWeightsMetadata!-Tuple{Dict, String, String}","page":"Home","title":"ModelWeights.setRefPeriodInWeightsMetadata!","text":"setRefPeriodInWeightsMetadata!(meta::Dict, alias::String, timerange::String)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.setToSummarizedMembers!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.setToSummarizedMembers!","text":"setToSummarizedMembers!(data::DataMap)\n\nSet values for every dataset in data to the average across all members of  each model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.sortLongitudesWest2East-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.sortLongitudesWest2East","text":"sortLongitudesWest2East(data::AbstractArray)\n\nArrange 'data' such that western latitudes come first, then eastern latitudes.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.subsetModelData-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.subsetModelData","text":"subsetModelData(datamap::DataMap; level::LEVEL=MEMBER)\n\nFor those datasets in datamap that specify data on the level level  (i.e. have dimension :member or :model), return a new DataMap with subset of  data s.t. the new datasets all have the same models (level=MODEL) or members  (level=MEMBER).\n\nIf no models are shared across datasets, return the input datamap.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.subsetModelData-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.subsetModelData","text":"subsetModelData(data::AbstractArray, shared_models::Vector{String})\n\nReturn a YAXArray that is the subset of data containing only data from  the models specified in shared_models. \n\nTakes care of metadata.\n\nArguments:\n\ndata: must have dimension 'member' or 'model'\nshared_models: vector of models, which can either be on level of models \n\nor members of models ('modelname#memberID[_grid]').\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.summarizeEnsembleMembersVector-Tuple{YAXArrays.Cubes.YAXArray, Bool}","page":"Home","title":"ModelWeights.summarizeEnsembleMembersVector","text":"summarizeEnsembleMembersVector(\n    data::YAXArray, updateMeta::Bool; fn::Function=Statistics.mean\n\n)\n\nFor each model and variable (if several given), compute a summary statistic  (default: mean) across all members of that model. Instead of 'member', the  returned YAXArray has dimension 'model'.\n\nArguments:\n\ndata::YAXArray: a YAXArray with at least dimension 'member'\nupdateMeta::Bool: set true if the vectors in the metadata refer to \n\ndifferent models. Set to false if vectors refer to different variables.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.throwErrorIfModelDimMissing-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.throwErrorIfModelDimMissing","text":"throwErrorIfModelDimMissing(data::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.updateGroupedDataMetadata-Tuple{Dict, DimensionalData.DimGroupByArray}","page":"Home","title":"ModelWeights.updateGroupedDataMetadata","text":"updateGroupedDataMetadata(meta::Dict, grouped_data::DimensionalData.DimGroupByArray)\n\nSummarize vectors in meta, refering to different models (members), such that  each vector only contains N entries (N=number of models (i.e. without unique  members)).\n\nIf the metadata for members of a model differ across members, the respective entry in the vector will be a vector itself.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.updateMetadata!-Tuple{Dict{String, Any}, Vector{String}, Bool}","page":"Home","title":"ModelWeights.updateMetadata!","text":"updateMetadata!(\n    meta::Dict{String, Any},\n    source_names::Vector{String},\n    is_model_data::Bool\n)\n\nUpdate metadata meta s.t. attributes that were only present in some  files/models are set to missing. \n\nFurther key-value pairs are added concerning the data sources:\n\n'member_names' (for model data only): vector that contains for every model a \n\nvector with the unique names of that model's members identifier consisting of  variantlabel, modelname and for CMIP6 models also grid_label.\n\n'model_names': vector whose length is the sum of the number of all models' \n\nmembers (or vector of filenames of observational data); it contains the model  names for each unique model member, i.e. this vector will not be unique if any  model had several members.\n\nArguments:\n\nsource_names::Vector{String}: model names (or filenames of observational \n\ndata)as retrieved from the original files the data was loaded from. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.writeDataToDisk-Tuple{Any, String}","page":"Home","title":"ModelWeights.writeDataToDisk","text":"writeDataToDisk(data, target_path::String)\n\nSave data as Julia obj if target_path has ending '.jld2', otherwise save  as binary.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
